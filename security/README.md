# Security Plugin

The security plugin is a [goa v2](https://github.com/goadesign/goa/tree/v2)
plugin that makes it possible to define security schemes and identify endpoints
that require authorization. The following schemes are supported:

* basic authentication: basic auth as defined by RFC 2617
* API key: preshared secret
* JWT: JWT bearer tokens optionally carrying privileges in the form of scopes
* OAuth2: OAuth2 access tokens

In each case the plugin makes it possible to define the scheme and its
properties in the DSL. The schemes may then be applied to the whole API, to a
specific service or to a specific endpoint. Services and endpoints may also
override the defaults set at the API or service level.

The code generated by goa makes the information needed to authorize available to
the service methods.

## Enabling the plugin

To enable the plugin and make use of the security DSL simply import both the
`security` and the `dsl` packages as follows:

```go
import (
   _ "goa.design/plugins/security"
   . "goa.design/plugins/security/dsl"
   . "goa.design/goa/http/design"
)
```

Note the use of the blank identifier to import the security package which is
necessary as the package is imported solely for its side-effects (initialization).

## Effects on Code Generation

Concretely the generated transport code for secured endpoints extracts the
information needed to perform authorization from the transport specific data
(e.g. Authorization header) and initializes the corresponding payload fields
with it. The secured endpoints then invoke the authorization functions
(which makes use of the payload fields) as per the security requirements.

The plugin also modifies the generated OpenAPI specs to include security
information.

## Design

This plugins adds the following functions to the goa DSL:

* `BasicAuthSecurity`, `APIKeySecurity`, `OAuth2Security` and `JWTSecurity` are
  top level functions that describe security schemes.
* `Security` is used in `API`, `Service` and `Method` DSLs to define the
  security schemes that apply globally to all the endpoints defined in the
  design (`API`), to all the endpoints in a service (`Service`) or to a specific
  endpoint (`Method`). The functions also describe the scopes that must be
  provided in the authorization credentials if the scheme supports it (JWT or
  OAuth2).
* `NoSecurity` makes it possible to override the need for authorization on a
  specific endpoint.
* Scheme specific functions such as `Username` or `Password` make it possible to
  describe the mapping between the incoming credentials and the payload fields.

The usage and effect of the DSL functions are described in the [Go
docs](https://godoc.org/goa.design/plugins/security/dsl).

Here is an example defining a JWT security scheme:

```go
// JWT defines a JWT security scheme with two possible scopes.
var JWT = JWTSecurity("JWT", func() {
    Scope("api:read", "Read access")
    Scope("api:write", "Write access")
})
```

The security requirements are defined on the transport independent functions
`API`, `Service` and `Method`. For example the scheme defined above can be
applied to a method using:

```go
Method("secured", func() {
    Security(JWT)
    Payload(func() {
        // Token defines the attribute that contains the JWT token.
        Token("token", String, "JWT token used to perform authorization")
        Required("token")
    })
    Result(String)
    HTTP(func() {
        GET("/")
    })
})
```

The DSL provides functions that make it possible to define the attributes of the
method payload that map to security scheme properties such as the username,
password or JWT token. In the example above the `token` attribute of the payload
is defined using `Token` to signal that it contains the JWT token.

## Implementation

The generated secure endpoint code accepts authorization functions as
per the security schemes and requirements defined for the endpoint.
Users can define their own custom authorization function matching the
authorization function type defined in the security plugin. This custom
function can then be passed into the secure endpoints constructor.

```go
// CustomJWTAuth is the user-defined authorization logic for JWT scheme.
func CustomJWTAuth(ctx context.Context, token string, sch *security.JWTScheme) (context.Context, error) {
    // 1. Retrieve JWT token
    jwt, err := parseJWT(token) // parseJWT decodes the JWT token
    if err != nil {
       // Use error data structure generated from the corresponding Error
       // design expression.
       return ctx, &service.Unauthorized{Message: err.Error()}
    }

    // 2. Validate JWT claims against required scopes.
    var missing []string
    for _, r := range sch.RequiredScopes {
      var found bool
      for _, s := range jwt.Scopes {
        if s == r {
          found = true
          break
        }
      }
      if !found {
        missing = append(missing, r)
      }
    }

    if len(missing) == 0 {
      return ctx, nil
    }
    return ctx, fmt.Errorf("missing sopes: %s", strings.Join(missing, ", "))
}

// In cmd/svc/main.go
svcEndpoints := svc.NewSecureEndpoints(svcSvc, CustomJWTAuth)
```

See the [security example] (https://github.com/goadesign/plugins/tree/master/security/examples/calc)
for more implementation examples.

## Support for Multiple Schemes

The DSL makes it possible to define security requirements using the `Security`
function. Each requirement consists of one or more security schemes that must
all be validated by requests. For example a security requirement may specify
that both an API key and a username and password must be provided to authorize
requests. A requirement is thus an "and-ed" list of security schemes:

```go
Method("secured", func() {
    // Require both basic auth and API key
    Security(BasicAuth, APIKey)

    ...
}
```

If an endpoint specifies more than one requirement then the request must
validate *one of* the requirements. The list of requirements thus defines an
"or-ed" list of "anded-ed" lists of security schemes. Security requirements are
defined with the `Security` function which accepts an arbitrary number of
schemes as shown in the example above. The function may appear multiple times in
the same scope to provide the alternatives.

To expand on the example an additional security requirement could be defined on
the "secured" endpoint to provide an alternative to the API key +
username/password combo, for example a JWT token:

```go
Method("secured", func() {
    // Require both basic auth and API key
    Security(BasicAuth, APIKey)

    // OR JWT token
    Security(JWT, func() {
        Scope("api:read")
    })

    ...
}
```
