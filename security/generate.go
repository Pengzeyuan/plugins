package security

import (
	"path/filepath"
	"strings"

	"goa.design/goa/codegen"
	"goa.design/goa/codegen/service"
	goadesign "goa.design/goa/design"
	"goa.design/goa/eval"
	"goa.design/plugins/security/design"
)

type (
	// ServiceData contains the data necessary to render the secure endpoints
	// constructor.
	ServiceData struct {
		// Name is the name of the service.
		Name string
		// VarName is the Go name of the service interface.
		VarName string
		// PkgName is the name of the service package.
		PkgName string
		// EndpointsVarName is the Go endpoints struct name.
		EndpointsVarName string
		// Methods list the endpoint constructors.
		Methods []*MethodData
	}

	// MethodData contains the data necessry to render
	// endpoints.
	MethodData struct {
		// VarName is the goified name of the constructor method. It
		// differs to the name generated by goa when the endpoint
		// defines security scheme.
		VarName string
		// NonSecureVarName is the goified name of constructor method
		// generated by goa.
		NonSecureVarName string
		// FieldName is the name of the corresponding endpoints struct
		// field.
		FieldName string
		// ServiceName is the name of the corresponding service.
		ServiceName string
		// MethodName is the name of the corresponding service method.
		MethodName string
		// Requirements lists the security requirements that apply to
		// the secured method.
		Requirements []*design.SecurityExpr
	}
)

// Register the plugin Generator functions.
func init() {
	codegen.RegisterPlugin("gen", Generate)
	codegen.RegisterPlugin("example", Example)
}

// Generate produces server code that enforce the security requirements defined
// in the design. Generate also produces client code that makes it possible to
// provide the required security artifacts. Finally Generate also generate code
// that initializes the context given to the service methods with security
// information.
func Generate(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	for _, root := range roots {
		switch r := root.(type) {
		case *goadesign.RootExpr:
			for _, s := range r.Services {
				if f := SecureEndpointFile(genpkg, s); f != nil {
					files = append(files, f)
				}
			}
		}
	}
	return files, nil
}

// SecureEndpointFile returns the file containing the secure endpoint
// definitions.
func SecureEndpointFile(genpkg string, svc *goadesign.ServiceExpr) *codegen.File {
	data := BuildSecureServiceData(svc)
	path := filepath.Join(codegen.Gendir, codegen.SnakeCase(svc.Name), "security.go")
	header := codegen.Header(
		svc.Name+" service security",
		data.PkgName,
		[]*codegen.ImportSpec{
			{Path: "context"},
			{Path: "goa.design/goa"},
			{Path: "goa.design/plugins/security"},
		})
	init := &codegen.SectionTemplate{
		Name:    "secure-endpoint-init",
		Source:  secureEndpointsInitT,
		Data:    data,
		FuncMap: codegen.TemplateFuncs(),
	}
	sections := []*codegen.SectionTemplate{header, init}
	for _, m := range data.Methods {
		if len(m.Requirements) == 0 {
			continue
		}
		sections = append(sections, &codegen.SectionTemplate{
			Source: secureEndpointContextT,
			Data:   m,
		})
	}
	if len(sections) == 1 {
		return nil
	}
	return &codegen.File{
		Path:             path,
		SectionTemplates: sections,
	}
}

// Example modified the generated main function so that the secured endpoints
// context gets initialized with the security requirements.
func Example(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	for _, f := range files {
		for _, s := range f.Section("service-main") {
			s.Source = strings.Replace(
				s.Source,
				"{{ .Service.PkgName }}Endpoints = {{ .Service.PkgName }}.NewEndpoints({{ .Service.PkgName }}Svc)",
				"{{ .Service.PkgName }}Endpoints = {{ .Service.PkgName }}.NewSecureEndpoints({{ .Service.PkgName }}Svc)",
				1,
			)
		}
	}
	return files, nil
}

// BuildSecureServiceData builds the data needed to render the secured endpoints
// struct constructor and the secure endpoint methods.
func BuildSecureServiceData(svc *goadesign.ServiceExpr) *ServiceData {
	s := service.Services.Get(svc.Name)
	data := &ServiceData{
		Name:             svc.Name,
		PkgName:          s.PkgName,
		VarName:          service.ServiceInterfaceName,
		EndpointsVarName: service.EndpointsStructName,
	}
	for _, m := range svc.Methods {
		reqs := design.Requirements(svc.Name, m.Name)
		varn := s.Method(m.Name).VarName
		cn := "New" + varn
		if len(reqs) > 0 {
			cn = "Secure" + varn
		}
		data.Methods = append(data.Methods, &MethodData{
			VarName:          cn,
			NonSecureVarName: "New" + varn + "Endpoint",
			FieldName:        varn,
			ServiceName:      svc.Name,
			MethodName:       m.Name,
			Requirements:     design.Requirements(svc.Name, m.Name),
		})
	}
	return data
}

// input: securedServiceData
const secureEndpointsInitT = `{{ printf "NewSecure%s wraps the methods of a %s service with security scheme aware endpoints." .EndpointsVarName .Name | comment }}
	func NewSecure{{ .EndpointsVarName }}(s {{ .VarName }}) *{{ .EndpointsVarName }} {
		return &{{ .EndpointsVarName }}{
			{{- range .Methods }}
			{{ .FieldName }}: {{ .VarName }}{{ if .Requirements }}({{ .NonSecureVarName }}{{ end }}(s){{ if .Requirements }}){{ end }},
			{{- end }}
		}
	}
	`

// input: securedServiceMethodData
const secureEndpointContextT = `{{ printf "%s returns an endpoint function which initializes the context with the security requirements for the method %q of service %q." .VarName .MethodName .ServiceName | comment }}
	func {{ .VarName }}(ep goa.Endpoint) goa.Endpoint {
		reqs := make([]*security.Requirement, {{ len .Requirements }})
		{{- range $i, $req := .Requirements }}
		{{- if $req.Scopes }}
		reqs[{{ $i }}].RequiredScopes = []string{ {{- range $req.Scopes }}{{ printf "%q" . }}, {{ end }} }
		{{- end }}
		reqs[{{ $i }}].Schemes = make([]*security.Scheme, {{ len .Schemes }})
		{{- range $j, $scheme := .Schemes }}
		reqs[{{ $i }}].Schemes[{{ $j }}] = &security.Scheme{
			Kind: security.SchemeKind({{ $scheme.Kind }}),
			Name: {{ printf "%q" $scheme.SchemeName }},
		}
		{{- if .Scopes }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Scopes = []string{ {{- range $scheme.Scopes }}{{ printf "%q" .Name }}, {{ end }} }
		{{- end }}
		{{- if .In }}
		reqs[{{ $i }}].Schemes[{{ $j }}].APIKey = &security.Key{
			In: {{ printf "%q" .In }},
			Name: {{ printf "%q" .Name }},
		}
		{{- end }}
		{{- if .Flows }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Flows = make([]*security.OAuthFlow, {{ len .Flows }})
		{{- range $j, $flow := .Flows }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Flows[{{ $j }}] = &security.OAuthFlow{
			Kind: security.FlowKind({{ $flow.Kind }}),
		}
		{{- if .AuthorizationURL }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Flows[{{ $j }}].AuthorizationURL = {{ printf "%q" .AuthorizationURL }}
		{{- end }}
		{{- if .TokenURL }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Flows[{{ $j }}].TokenURL = {{ printf "%q" .TokenURL }}
		{{- end }}
		{{- if .RefreshURL }}
		reqs[{{ $i }}].Schemes[{{ $j }}].Flows[{{ $j }}].RefreshURL = {{ printf "%q" .RefreshURL }}
		{{- end }}
		{{- end }}
		{{- end }}
		{{- end }}
		{{- end }}
		return func(ctx context.Context, req interface{}) (interface{}, error) {
			ctx = context.WithValue(ctx, security.ContextKey, reqs)
			return ep(ctx, req)
		}
	}
	`
