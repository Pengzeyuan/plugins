package http

import (
	"fmt"
	"strings"

	"goa.design/goa/codegen"
	goadesign "goa.design/goa/design"
	"goa.design/goa/eval"
	httpcodegen "goa.design/goa/http/codegen"
	"goa.design/goa/http/codegen/openapi"
	httpdesign "goa.design/goa/http/design"
	seccodegen "goa.design/plugins/security/codegen"
	"goa.design/plugins/security/design"
)

type (
	// ServiceData contains the data necessary to render the secure endpoints
	// constructor in example.
	ServiceData struct {
		*httpcodegen.ServiceData
		// Schemes is the unique security schemes for the service.
		Schemes []*design.SchemeExpr
	}

	// SecureDecoderData contains the data necessary to render the security aware
	// HTTP decoder.
	SecureDecoderData struct {
		// ServiceName is the name of the service.
		ServiceName string
		// MethodName is the name of the method.
		MethodName string
		// SecureRequestDecoder is the name of the generated decoder function.
		SecureRequestDecoder string
		// RequestDecoder is the name of the decoder function
		// originally generated by goa.
		RequestDecoder string
		// PayloadType is the Go type name of the secured method payload.
		PayloadType string
		// Schemes contains the security scheme data needed to render the auth
		// code.
		Schemes []*seccodegen.SchemeData
	}

	// SecureEncoderData contains the data necessary to render the security aware
	// HTTP encoder.
	SecureEncoderData struct {
		// ServiceName is the name of the service.
		ServiceName string
		// MethodName is the name of the method.
		MethodName string
		// SecureRequestEncoder is the name of the generated encoder function.
		SecureRequestEncoder string
		// RequestEncoder is the name of the encoder function
		// originally generated by goa.
		RequestEncoder string
		// PayloadType is the Go type name of the secured method payload.
		PayloadType string
		// Schemes contains the security scheme data needed to render the auth
		// code.
		Schemes []*seccodegen.SchemeData
	}
)

// Register the plugin HTTP Generator function.
func init() {
	codegen.RegisterPlugin("gen", Generate)
	codegen.RegisterPlugin("example", Example)
}

// Generate produces HTTP decoders and encoders that initialize the
// security attributes.
func Generate(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	for _, root := range roots {
		switch r := root.(type) {
		case *httpdesign.RootExpr:
			for _, f := range files {
				SecureRequestDecoders(r, f)
				SecureRequestEncoders(r, f)
				OpenAPIV2(r, f)
			}
		}
	}
	return files, nil
}

// Example modified the generated main function so that the secured endpoints
// context gets initialized with the security requirements.
func Example(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	var (
		apiPkg  string
		data    = make(map[string]*seccodegen.ServiceData)
		svcData []*ServiceData
	)
	for _, root := range roots {
		switch r := root.(type) {
		case *goadesign.RootExpr:
			apiPkg = strings.ToLower(codegen.Goify(r.API.Name, false))
			for _, s := range r.Services {
				data[s.Name] = seccodegen.BuildSecureServiceData(s, apiPkg)
			}
		case *httpdesign.RootExpr:
			for _, s := range r.HTTPServices {
				sd := httpcodegen.HTTPServices.Get(s.Name())
				svcData = append(svcData, &ServiceData{ServiceData: sd})
			}
		}
	}
	for _, svc := range svcData {
		if d, ok := data[svc.ServiceData.Service.Name]; ok {
			svc.Schemes = d.Schemes
		}
	}
	for _, f := range files {
		for _, s := range f.Section("service-main") {
			s.Source = strings.Replace(
				s.Source,
				"{{- range .Services }}",
				"{{- range $svc := .Services }}",
				-1,
			)
			s.Source = strings.Replace(
				s.Source,
				"{{ .Service.PkgName }}.NewEndpoints({{ .Service.VarName }}Svc)",
				"{{ .Service.PkgName }}.NewSecureEndpoints({{ .Service.VarName }}Svc{{ range .Schemes }}, {{ $.APIPkg }}.{{ $svc.Service.StructName }}Auth{{ .Type }}Fn{{ end }})",
				1,
			)
			sData := s.Data.(map[string]interface{})
			sData["Services"] = svcData
		}
	}
	return files, nil
}

// SecureRequestDecoders initializes the security attributes for HTTP request decoders.
func SecureRequestDecoders(r *httpdesign.RootExpr, f *codegen.File) {
	needsImport := false
	for _, s := range f.Section("server-handler-init") {
		needsImport = true
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		if len(design.Requirements(e.Service.Name(), e.Name())) > 0 {
			s.Source = strings.Replace(s.Source, "{{ .RequestDecoder }}", "Secure{{ .RequestDecoder }}", -1)
		}
	}
	if needsImport {
		codegen.AddImport(f.SectionTemplates[0],
			&codegen.ImportSpec{Path: "goa.design/plugins/security"})
	}
	var schemes []*seccodegen.SchemeData
	for _, s := range f.Section("request-decoder") {
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		schemes = computeSchemes(e)
		if len(schemes) == 0 {
			continue
		}
		f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
			Name:   "secure-request-decoder",
			Source: authDecoderT,
			Data: &SecureDecoderData{
				SecureRequestDecoder: "Secure" + data.RequestDecoder,
				RequestDecoder:       data.RequestDecoder,
				PayloadType:          data.Payload.Ref,
				Schemes:              schemes,
				ServiceName:          data.ServiceName,
				MethodName:           data.Method.Name,
			},
			FuncMap: codegen.TemplateFuncs(),
		})
	}
}

// SecureRequestEncoders initializes the security attributes for HTTP encoders.
func SecureRequestEncoders(r *httpdesign.RootExpr, f *codegen.File) {
	needsImport := false
	for _, s := range f.Section("client-endpoint-init") {
		needsImport = true
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		if len(design.Requirements(e.Service.Name(), e.Name())) > 0 {
			s.Source = strings.Replace(s.Source, "{{ .RequestEncoder }}", "Secure{{ .RequestEncoder }}", -1)
		}
	}
	if needsImport {
		codegen.AddImport(f.SectionTemplates[0],
			&codegen.ImportSpec{Path: "goa.design/plugins/security"})
	}
	var schemes []*seccodegen.SchemeData
	for _, s := range f.Section("request-encoder") {
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		schemes = computeSchemes(e)
		if len(schemes) == 0 {
			continue
		}
		f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
			Name:   "secure-request-encoder",
			Source: authEncoderT,
			Data: &SecureEncoderData{
				SecureRequestEncoder: "Secure" + data.RequestEncoder,
				RequestEncoder:       data.RequestEncoder,
				PayloadType:          data.Payload.Ref,
				Schemes:              schemes,
				ServiceName:          data.ServiceName,
				MethodName:           data.Method.Name,
			},
			FuncMap: codegen.TemplateFuncs(),
		})
	}
}

// OpenAPIV2 adds the security requirements for the HTTP endpoints.
func OpenAPIV2(r *httpdesign.RootExpr, f *codegen.File) {
	for _, s := range f.Section("openapi") {
		spec := s.Data.(*openapi.V2)
		for _, svc := range r.HTTPServices {
			for _, e := range svc.HTTPEndpoints {
				reqs := design.Requirements(svc.Name(), e.Name())
				for _, route := range e.Routes {
					var (
						p  *openapi.Path
						op *openapi.Operation
					)
					for path, v := range spec.Paths {
						for _, rPath := range route.FullPaths() {
							if rPath == path {
								p = v.(*openapi.Path)
								break
							}
						}
					}
					if p == nil {
						continue
					}
					switch route.Method {
					case "GET":
						op = p.Get
					case "PUT":
						op = p.Put
					case "POST":
						op = p.Post
					case "DELETE":
						op = p.Delete
					case "OPTIONS":
						op = p.Options
					case "HEAD":
						op = p.Head
					case "PATCH":
						op = p.Patch
					}
					applySecurity(op, reqs)
				}
			}
		}
		s.Data = spec
	}
}

// applySecurity applies the security requirements to the openapi V2 operation.
func applySecurity(op *openapi.Operation, reqs []*design.SecurityExpr) {
	if len(reqs) == 0 {
		return
	}
	requirements := make([]map[string][]string, len(reqs))
	for i, req := range reqs {
		requirement := make(map[string][]string)
		for _, s := range req.Schemes {
			requirement[s.SchemeName] = []string{}
			switch s.Kind {
			case design.OAuth2Kind:
				for _, scope := range req.Scopes {
					requirement[s.SchemeName] = append(requirement[s.SchemeName], scope)
				}
			case design.JWTKind:
				lines := make([]string, 0, len(req.Scopes))
				for _, scope := range req.Scopes {
					lines = append(lines, fmt.Sprintf("  * `%s`", scope))
				}
				if op.Description != "" {
					op.Description += "\n"
				}
				op.Description += fmt.Sprintf("\nRequired security scopes:\n%s", strings.Join(lines, "\n"))
			}
		}
		requirements[i] = requirement
	}
	op.Security = requirements
}

// computeSchemes collects the security schemes for the given endpoint.
func computeSchemes(e *httpdesign.EndpointExpr) []*seccodegen.SchemeData {
	var schemes []*seccodegen.SchemeData
	for _, req := range design.Requirements(e.Service.Name(), e.Name()) {
		for _, s := range req.Schemes {
			if sd := seccodegen.BuildSchemeData(s, e.MethodExpr); sd != nil {
				scheme := *s
				if scheme.Kind == design.APIKeyKind || scheme.Kind == design.OAuth2Kind {
					var name string
					name, scheme.In = findKey(e, sd.KeyAttr)
					if name != "" {
						scheme.Name = name
					}
				}
				sd.Scheme = &scheme
				schemes = append(schemes, sd)
			}
		}
	}
	return schemes
}

// findKey finds the given key in the endpoint expression and returns the
// transport element name and the position (header or query).
func findKey(e *httpdesign.EndpointExpr, keyAtt string) (string, string) {
	if n, exists := e.AllParams().FindKey(keyAtt); exists {
		return n, "query"
	} else if n, exists := e.MappedHeaders().FindKey(keyAtt); exists {
		return n, "header"
	} else {
		return "", "header"
	}
}

// input: SecureDecoderData
const authDecoderT = `{{ printf "%s returns a decoder for requests sent to the %s %s endpoint that is security scheme aware." .SecureRequestDecoder .ServiceName .MethodName | comment }}
func {{ .SecureRequestDecoder }}(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	rawDecoder := {{ .RequestDecoder }}(mux, decoder)
	return func(r *http.Request) (interface{}, error) {
		p, err := rawDecoder(r)
		if err != nil {
			return nil, err
		}
		payload := p.({{ .PayloadType }})
{{- range .Schemes }}

	{{- if eq .Scheme.Kind 2 }}{{/* BasicAuth */}}
		user, pass, ok := r.BasicAuth()
		if !ok {
			return p, nil
		}
		payload.{{ .UsernameField }} = {{ if .UsernamePointer }}&{{ end }}user
		payload.{{ .PasswordField }} = {{ if .PasswordPointer }}&{{ end }}pass

	{{- else if eq .Scheme.Kind 3 }}{{/* APIKey */}}
		{{- if eq .Scheme.In "query" }}
		key := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}key
		{{- else }}
		key := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}key
		{{- end }}

	{{- else }}{{/* OAuth2 and JWT */}}
		{{- if eq .Scheme.In "query" }}
		token{{ .Scheme.Type }} := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if token{{ .Scheme.Type }} == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}token{{ .Scheme.Type }}
		{{- else }}
		h{{ .Scheme.Type }} := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if h{{ .Scheme.Type }} == "" {
			return p, nil
		}
		token{{ .Scheme.Type }} := strings.TrimPrefix(h{{ .Scheme.Type }}, "Bearer ")
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}token{{ .Scheme.Type }}
		{{- end }}

	{{- end }}

{{- end }}
		return payload, nil
	}
}
`

// input: SecureEncoderData
const authEncoderT = `{{ printf "%s returns an encoder for requests sent to the %s %s endpoint that is security scheme aware." .SecureRequestEncoder .ServiceName .MethodName | comment }}
func {{ .SecureRequestEncoder }}(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	rawEncoder := {{ .RequestEncoder }}(encoder)
	return func(req *http.Request, v interface{}) error {
		if err := rawEncoder(req, v); err != nil {
			return err
		}
		payload := v.({{ .PayloadType }})
{{- range .Schemes }}

	{{- if eq .Scheme.Kind 2 }}{{/* BasicAuth */}}
		req.SetBasicAuth({{ if .UsernamePointer }}*{{ end }}payload.{{ .UsernameField }}, {{ if .PasswordPointer }}*{{ end }}payload.{{ .PasswordField }})

	{{- else if eq .Scheme.Kind 3 }}{{/* APIKey */}}
		{{- if eq .Scheme.In "query" }}
		req.URL.Query().Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- else }}
		req.Header.Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- end }}

	{{- else }}{{/* OAuth2 and JWT */}}
		{{- if eq .Scheme.In "query" }}
		req.URL.Query().Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- else }}
		req.Header.Set({{ printf "%q" .Scheme.Name }}, fmt.Sprintf("Bearer %s", {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }}))
		{{- end }}

	{{- end }}

{{- end }}
		return nil
	}
}
`
