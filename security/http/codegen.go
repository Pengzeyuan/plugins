package http

import (
	"fmt"
	"strings"

	"goa.design/goa/codegen"
	goadesign "goa.design/goa/design"
	httpcodegen "goa.design/goa/http/codegen"
	"goa.design/plugins/security/design"
)

// SecureDecoderData contains the data necessary to render the security aware
// HTTP decoder.
type SecureDecoderData struct {
	// ServiceName is the name of the service.
	ServiceName string
	// MethodName is the name of the method.
	MethodName string
	// RequestDecoder is the name of the generated decoder function.
	SecureRequestDecoder string
	// RequestDecoder is the name of the decoder function
	// originally generated by goa.
	RequestDecoder string
	// PayloadType is the Go type name of the secured method payload.
	PayloadType string
	// Schemes contains the security scheme data needed to render the auth
	// code.
	Schemes []*SchemeData
}

// SchemeData describes a single security scheme.
type SchemeData struct {
	// UsernameField is the name of the payload field that should be
	// initialized with the basic auth username if any.
	UsernameField string
	// UsernamePointer is true if the username field is a pointer.
	UsernamePointer bool
	// PasswordField is the name of the payload field that should be
	// initialized with the basic auth password if any.
	PasswordField string
	// PasswordPointer is true if the password field is a pointer.
	PasswordPointer bool
	// CredField contains the name of the payload field that should
	// be initialized with the API key, the JWT token or the OAuth2
	// access token.
	CredField string
	// CredPointer is true if the credential field is a pointer.
	CredPointer bool
	// Scheme is the security scheme. Only initialized for API key
	// and JWT auth.
	Scheme *design.SchemeExpr
}

// Generate produces HTTP decoders that initialize the security attributes.
func Generate(files []*codegen.File) {
	for _, f := range files {
		needsImport := false
		for _, s := range f.Section("server-handler-init") {
			needsImport = true
			data := s.Data.(*httpcodegen.EndpointData)
			if len(design.Requirements(data.ServiceName, data.Method.Name)) > 0 {
				s.Source = strings.Replace(s.Source, "{{ .RequestDecoder }}", "Secure{{ .RequestDecoder }}", -1)
			}
		}
		if needsImport {
			codegen.AddImport(f.SectionTemplates[0],
				&codegen.ImportSpec{Path: "goa.design/plugins/security"})
		}
		for _, s := range f.Section("request-decoder") {
			data := s.Data.(*httpcodegen.EndpointData)
			payload := goadesign.Root.Service(data.ServiceName).Method(data.Method.Name).Payload

			var schemes []*SchemeData
			for _, req := range design.Requirements(data.ServiceName, data.Method.Name) {
				for _, scheme := range req.Schemes {
					switch scheme.Kind {
					case design.BasicAuthKind:
						var (
							user        string
							pass        string
							userPointer bool
							passPointer bool
						)
						if goadesign.IsObject(payload.Type) {
							var userAtt, passAtt string
							matt := goadesign.NewMappedAttributeExpr(payload)
							userAtt, user = findSecurityField(matt, "security:username")
							passAtt, pass = findSecurityField(matt, "security:password")
							userPointer = payload.IsPrimitivePointer(userAtt, true)
							passPointer = payload.IsPrimitivePointer(passAtt, true)
							schemes = append(schemes, &SchemeData{
								UsernameField:   user,
								UsernamePointer: userPointer,
								PasswordField:   pass,
								PasswordPointer: passPointer,
								Scheme:          scheme,
							})
						}
					case design.APIKeyKind:
						var (
							key        string
							keyPointer bool
						)
						if goadesign.IsObject(payload.Type) {
							matt := goadesign.NewMappedAttributeExpr(payload)
							var keyAtt string
							keyAtt, key = findSecurityField(matt, "security:apikey:"+scheme.SchemeName)
							if key == "" {
								continue
							}
							keyPointer = payload.IsPrimitivePointer(keyAtt, true)
							scheme.Name = matt.ElemName(keyAtt)
							inHeader := false
							for _, h := range data.Payload.Request.Headers {
								if h.AttributeName == keyAtt {
									inHeader = true
									break
								}
							}
							if inHeader {
								scheme.In = "header"
							} else {
								scheme.In = "query"
							}
							schemes = append(schemes, &SchemeData{
								CredField:   key,
								CredPointer: keyPointer,
								Scheme:      scheme,
							})
						}
					case design.JWTKind:
						var (
							key        string
							keyPointer bool
						)
						if goadesign.IsObject(payload.Type) {
							matt := goadesign.NewMappedAttributeExpr(payload)
							var keyAtt string
							keyAtt, key = findSecurityField(matt, "security:token")
							if key == "" {
								continue
							}
							keyPointer = payload.IsPrimitivePointer(keyAtt, true)
							schemes = append(schemes, &SchemeData{
								CredField:   key,
								CredPointer: keyPointer,
								Scheme:      scheme,
							})
						}
					case design.OAuth2Kind:
						var (
							key        string
							keyPointer bool
						)
						if goadesign.IsObject(payload.Type) {
							matt := goadesign.NewMappedAttributeExpr(payload)
							var keyAtt string
							keyAtt, key = findSecurityField(matt, "security:accesstoken")
							if key == "" {
								continue
							}
							keyPointer = payload.IsPrimitivePointer(keyAtt, true)
							schemes = append(schemes, &SchemeData{
								CredField:   key,
								CredPointer: keyPointer,
								Scheme:      scheme,
							})
						}
					default:
						panic(fmt.Sprintf("unknown kind %#v", scheme.Kind)) // bug
					}
				}
			}
			if len(schemes) == 0 {
				continue
			}
			secureData := &SecureDecoderData{
				SecureRequestDecoder: "Secure" + data.RequestDecoder,
				RequestDecoder:       data.RequestDecoder,
				PayloadType:          data.Payload.Ref,
				Schemes:              schemes,
				ServiceName:          data.ServiceName,
				MethodName:           data.Method.Name,
			}
			f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
				Name:    "secure-request-decoder",
				Source:  authDecoderT,
				Data:    secureData,
				FuncMap: codegen.TemplateFuncs(),
			})
		}
	}
}

// findSecurityField returns the name and corresponding field name of child
// attribute of p with the given tag if p is an object.
func findSecurityField(p *goadesign.MappedAttributeExpr, tag string) (string, string) {
	obj := goadesign.AsObject(p.Type)
	if obj == nil {
		return "", ""
	}
	for _, at := range *obj {
		if _, ok := at.Attribute.Metadata[tag]; ok {
			n := p.ElemName(at.Name)
			return at.Name, codegen.Goify(n, true)
		}
	}
	return "", ""
}

// input: SecureDecoderData
const authDecoderT = `{{ printf "%s returns a decoder for requests sent to the %s %s endpoint that is security scheme aware." .SecureRequestDecoder .ServiceName .MethodName | comment }}
func {{ .SecureRequestDecoder }}(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	rawDecoder := {{ .RequestDecoder }}(mux, decoder)
	return func(r *http.Request) (interface{}, error) {
		p, err := rawDecoder(r)
		if err != nil {
			return nil, err
		}
		payload := p.({{ .PayloadType }})
{{- range .Schemes }}

	{{- if eq .Scheme.Kind 2 }}{{/* BasicAuth */}}
		user, pass, ok := r.BasicAuth()
		if !ok {
			return p, nil
		}
		payload.{{ .UsernameField }} = {{ if .UsernamePointer }}&{{ end }}user
		payload.{{ .PasswordField }} = {{ if .PasswordPointer }}&{{ end }}pass

	{{- else if eq .Scheme.Kind 3 }}{{/* APIKey */}}
		{{- if eq .Scheme.In "query" }}
		key := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload{{ if .CredField }}.{{ .CredField }}{{ end }} = {{ if .CredPointer }}&{{ end }}key
		{{- else }}
		key := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload{{ if .CredField }}.{{ .CredField }}{{ end }} = {{ if .CredPointer }}&{{ end }}key
		{{- end }}

	{{- else }}{{/* OAuth2 and JWT */}}
		{{- if eq .Scheme.In "query" }}
		token := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if token == "" {
			return p, nil
		}
		payload{{ if .CredField }}.{{ .CredField }}{{ end }} = {{ if .CredPointer }}&{{ end }}token
		{{- else }}
		h := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if h == "" {
			return p, nil
		}
		token := strings.TrimPrefix(h, "Bearer ")
		payload{{ if .CredField }}.{{ .CredField }}{{ end }} = {{ if .CredPointer }}&{{ end }}token
		{{- end }}

	{{- end }}

{{- end }}
		return payload, nil
	}
}
`
