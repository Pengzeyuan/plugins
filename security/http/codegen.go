package http

import (
	"fmt"
	"strings"

	"goa.design/goa/codegen"
	goadesign "goa.design/goa/design"
	"goa.design/goa/eval"
	httpcodegen "goa.design/goa/http/codegen"
	httpdesign "goa.design/goa/http/design"
	"goa.design/plugins/security/design"
)

// SecureDecoderData contains the data necessary to render the security aware
// HTTP decoder.
type SecureDecoderData struct {
	// ServiceName is the name of the service.
	ServiceName string
	// MethodName is the name of the method.
	MethodName string
	// SecureRequestDecoder is the name of the generated decoder function.
	SecureRequestDecoder string
	// RequestDecoder is the name of the decoder function
	// originally generated by goa.
	RequestDecoder string
	// PayloadType is the Go type name of the secured method payload.
	PayloadType string
	// Schemes contains the security scheme data needed to render the auth
	// code.
	Schemes []*SchemeData
}

// SecureEncoderData contains the data necessary to render the security aware
// HTTP encoder.
type SecureEncoderData struct {
	// ServiceName is the name of the service.
	ServiceName string
	// MethodName is the name of the method.
	MethodName string
	// SecureRequestEncoder is the name of the generated encoder function.
	SecureRequestEncoder string
	// RequestEncoder is the name of the encoder function
	// originally generated by goa.
	RequestEncoder string
	// PayloadType is the Go type name of the secured method payload.
	PayloadType string
	// Schemes contains the security scheme data needed to render the auth
	// code.
	Schemes []*SchemeData
}

// SchemeData describes a single security scheme.
type SchemeData struct {
	// UsernameField is the name of the payload field that should be
	// initialized with the basic auth username if any.
	UsernameField string
	// UsernamePointer is true if the username field is a pointer.
	UsernamePointer bool
	// PasswordField is the name of the payload field that should be
	// initialized with the basic auth password if any.
	PasswordField string
	// PasswordPointer is true if the password field is a pointer.
	PasswordPointer bool
	// CredField contains the name of the payload field that should
	// be initialized with the API key, the JWT token or the OAuth2
	// access token.
	CredField string
	// CredPointer is true if the credential field is a pointer.
	CredPointer bool
	// Scheme is the security scheme. Only initialized for API key
	// and JWT auth.
	Scheme *design.SchemeExpr
}

// Register the plugin HTTP Generator function.
func init() {
	codegen.RegisterPlugin("gen", Generate)
}

// Generate produces HTTP decoders and encoders that initialize the
// security attributes.
func Generate(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	for _, root := range roots {
		switch r := root.(type) {
		case *httpdesign.RootExpr:
			for _, f := range files {
				SecureRequestDecoders(r, f)
				SecureRequestEncoders(r, f)
			}
		}
	}
	return files, nil
}

// SecureRequestDecoders initializes the security attributes for HTTP request decoders.
func SecureRequestDecoders(r *httpdesign.RootExpr, f *codegen.File) {
	needsImport := false
	for _, s := range f.Section("server-handler-init") {
		needsImport = true
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		if len(design.Requirements(e.Service.Name(), e.Name())) > 0 {
			s.Source = strings.Replace(s.Source, "{{ .RequestDecoder }}", "Secure{{ .RequestDecoder }}", -1)
		}
	}
	if needsImport {
		codegen.AddImport(f.SectionTemplates[0],
			&codegen.ImportSpec{Path: "goa.design/plugins/security"})
	}
	var schemes []*SchemeData
	for _, s := range f.Section("request-decoder") {
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		schemes = getSchemesForEndpoint(e)
		if len(schemes) == 0 {
			continue
		}
		f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
			Name:   "secure-request-decoder",
			Source: authDecoderT,
			Data: &SecureDecoderData{
				SecureRequestDecoder: "Secure" + data.RequestDecoder,
				RequestDecoder:       data.RequestDecoder,
				PayloadType:          data.Payload.Ref,
				Schemes:              schemes,
				ServiceName:          data.ServiceName,
				MethodName:           data.Method.Name,
			},
			FuncMap: codegen.TemplateFuncs(),
		})
	}
}

// SecureRequestEncoders initializes the security attributes for HTTP encoders.
func SecureRequestEncoders(r *httpdesign.RootExpr, f *codegen.File) {
	needsImport := false
	for _, s := range f.Section("client-endpoint-init") {
		needsImport = true
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		if len(design.Requirements(e.Service.Name(), e.Name())) > 0 {
			s.Source = strings.Replace(s.Source, "{{ .RequestEncoder }}", "Secure{{ .RequestEncoder }}", -1)
		}
	}
	if needsImport {
		codegen.AddImport(f.SectionTemplates[0],
			&codegen.ImportSpec{Path: "goa.design/plugins/security"})
	}
	var schemes []*SchemeData
	for _, s := range f.Section("request-encoder") {
		data := s.Data.(*httpcodegen.EndpointData)
		e := r.Service(data.ServiceName).Endpoint(data.Method.Name)
		schemes = getSchemesForEndpoint(e)
		if len(schemes) == 0 {
			continue
		}
		f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
			Name:   "secure-request-encoder",
			Source: authEncoderT,
			Data: &SecureEncoderData{
				SecureRequestEncoder: "Secure" + data.RequestEncoder,
				RequestEncoder:       data.RequestEncoder,
				PayloadType:          data.Payload.Ref,
				Schemes:              schemes,
				ServiceName:          data.ServiceName,
				MethodName:           data.Method.Name,
			},
			FuncMap: codegen.TemplateFuncs(),
		})
	}
}

// getSchemesForEndpoint collects the security schemes for the given endpoint.
func getSchemesForEndpoint(e *httpdesign.EndpointExpr) []*SchemeData {
	payload := e.MethodExpr.Payload
	var schemes []*SchemeData
	for _, req := range design.Requirements(e.Service.Name(), e.Name()) {
		for _, s := range req.Schemes {
			scheme := *s
			switch scheme.Kind {
			case design.BasicAuthKind:
				if goadesign.IsObject(payload.Type) {
					userAtt, user := findSecurityField(payload, "security:username")
					passAtt, pass := findSecurityField(payload, "security:password")
					schemes = append(schemes, &SchemeData{
						UsernameField:   user,
						UsernamePointer: payload.IsPrimitivePointer(userAtt, true),
						PasswordField:   pass,
						PasswordPointer: payload.IsPrimitivePointer(passAtt, true),
						Scheme:          &scheme,
					})
				}

			case design.APIKeyKind:
				if goadesign.IsObject(payload.Type) {
					keyAtt, key := findSecurityField(payload, "security:apikey:"+scheme.SchemeName)
					if key == "" {
						continue
					}
					name := findMappedName(e.AllParams(), keyAtt)
					if name != "" {
						scheme.In = "query"
					} else {
						name = findMappedName(e.MappedHeaders(), keyAtt)
						scheme.In = "header"
					}
					scheme.Name = name
					schemes = append(schemes, &SchemeData{
						CredField:   key,
						CredPointer: payload.IsPrimitivePointer(keyAtt, true),
						Scheme:      &scheme,
					})
				}

			case design.JWTKind:
				if goadesign.IsObject(payload.Type) {
					keyAtt, key := findSecurityField(payload, "security:token")
					if key == "" {
						continue
					}
					schemes = append(schemes, &SchemeData{
						CredField:   key,
						CredPointer: payload.IsPrimitivePointer(keyAtt, true),
						Scheme:      &scheme,
					})
				}

			case design.OAuth2Kind:
				if goadesign.IsObject(payload.Type) {
					keyAtt, key := findSecurityField(payload, "security:accesstoken")
					if key == "" {
						continue
					}
					name := findMappedName(e.AllParams(), keyAtt)
					if name != "" {
						scheme.In = "query"
					} else {
						name = findMappedName(e.MappedHeaders(), keyAtt)
						scheme.In = "header"
					}
					if name != "" {
						scheme.Name = name
					}
					schemes = append(schemes, &SchemeData{
						CredField:   key,
						CredPointer: payload.IsPrimitivePointer(keyAtt, true),
						Scheme:      &scheme,
					})
				}

			default:
				panic(fmt.Sprintf("unknown kind %#v", scheme.Kind)) // bug
			}
		}
	}
	return schemes
}

// findMappedName returns the mapped name for the given attribute name.
func findMappedName(p *goadesign.MappedAttributeExpr, keyAtt string) string {
	obj := goadesign.AsObject(p.Type)
	if obj == nil {
		return ""
	}
	for _, at := range *obj {
		if at.Name == keyAtt {
			return p.ElemName(keyAtt)
		}
	}
	return ""
}

// findSecurityField returns the name and corresponding field name of child
// attribute of p with the given tag if p is an object.
func findSecurityField(a *goadesign.AttributeExpr, tag string) (string, string) {
	obj := goadesign.AsObject(a.Type)
	if obj == nil {
		return "", ""
	}
	for _, at := range *obj {
		if _, ok := at.Attribute.Metadata[tag]; ok {
			return at.Name, codegen.Goify(at.Name, true)
		}
	}
	return "", ""
}

// input: SecureDecoderData
const authDecoderT = `{{ printf "%s returns a decoder for requests sent to the %s %s endpoint that is security scheme aware." .SecureRequestDecoder .ServiceName .MethodName | comment }}
func {{ .SecureRequestDecoder }}(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	rawDecoder := {{ .RequestDecoder }}(mux, decoder)
	return func(r *http.Request) (interface{}, error) {
		p, err := rawDecoder(r)
		if err != nil {
			return nil, err
		}
		payload := p.({{ .PayloadType }})
{{- range .Schemes }}

	{{- if eq .Scheme.Kind 2 }}{{/* BasicAuth */}}
		user, pass, ok := r.BasicAuth()
		if !ok {
			return p, nil
		}
		payload.{{ .UsernameField }} = {{ if .UsernamePointer }}&{{ end }}user
		payload.{{ .PasswordField }} = {{ if .PasswordPointer }}&{{ end }}pass

	{{- else if eq .Scheme.Kind 3 }}{{/* APIKey */}}
		{{- if eq .Scheme.In "query" }}
		key := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}key
		{{- else }}
		key := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if key == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}key
		{{- end }}

	{{- else }}{{/* OAuth2 and JWT */}}
		{{- if eq .Scheme.In "query" }}
		token := r.URL.Query().Get({{ printf "%q" .Scheme.Name }})
		if token == "" {
			return p, nil
		}
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}token
		{{- else }}
		h := r.Header.Get({{ printf "%q" .Scheme.Name }})
		if h == "" {
			return p, nil
		}
		token := strings.TrimPrefix(h, "Bearer ")
		payload.{{ .CredField }} = {{ if .CredPointer }}&{{ end }}token
		{{- end }}

	{{- end }}

{{- end }}
		return payload, nil
	}
}
`

// input: SecureEncoderData
const authEncoderT = `{{ printf "%s returns an encoder for requests sent to the %s %s endpoint that is security scheme aware." .SecureRequestEncoder .ServiceName .MethodName | comment }}
func {{ .SecureRequestEncoder }}(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	rawEncoder := {{ .RequestEncoder }}(encoder)
	return func(req *http.Request, v interface{}) error {
		if err := rawEncoder(req, v); err != nil {
			return err
		}
		payload := v.({{ .PayloadType }})
{{- range .Schemes }}

	{{- if eq .Scheme.Kind 2 }}{{/* BasicAuth */}}
		req.SetBasicAuth({{ if .UsernamePointer }}*{{ end }}payload.{{ .UsernameField }}, {{ if .PasswordPointer }}*{{ end }}payload.{{ .PasswordField }})

	{{- else if eq .Scheme.Kind 3 }}{{/* APIKey */}}
		{{- if eq .Scheme.In "query" }}
		req.URL.Query().Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- else }}
		req.Header.Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- end }}

	{{- else }}{{/* OAuth2 and JWT */}}
		{{- if eq .Scheme.In "query" }}
		req.URL.Query().Set({{ printf "%q" .Scheme.Name }}, {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }})
		{{- else }}
		req.Header.Set({{ printf "%q" .Scheme.Name }}, fmt.Sprintf("Bearer %s", {{ if .CredPointer }}*{{ end }}payload.{{ .CredField }}))
		{{- end }}

	{{- end }}

{{- end }}
		return nil
	}
}
`
